<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <!-- New: modern mobile web app capability meta (recommended) -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Burn2Cool Dashboard</title>
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <div class='topbar'><a href='https://github.com/DiabloPower/burn2cool' target='_blank' rel='noopener'>GitHub</a><div class='version'>v?</div></div>
    <h1>Burn2Cool Dashboard</h1>
    <div class='cards-grid'>
    <div class='card status-card'>
      <h2>Current Status</h2>
      <div class='card-body'>
      <div class='status-grid'>
        <div class='status-row'><div class='label'>Temperature</div><div class='value' id='temp'>--</div></div>
        <div class='status-row'><div class='label'>Frequency</div><div class='value' id='freq'>--</div></div>
        <div class='status-row'><div class='label'>Sensor Source</div><div class='value' id='sensor_source'>--</div></div>
        <div class='status-row'><div class='label'>Sensor <span id='sensor'>--</span></div></div>
        <div class='status-row'><div class='label'>Use Avg Temp</div><div class='value' id='avg'>--</div></div>
        <div class='status-row'><div class='label'>Daemon user</div><div class='value' id='daemon_user'>--</div></div>
      </div>
      </div>
    </div>
    <div class='card profiles-card'>
      <h2>Profiles</h2>
      <div class='card-body'>
      <div class='label profiles-row'>
        <label for='profilesSelect'>Choose profile:</label>
        <select id='profilesSelect' class='profiles-select'>
          <option value=''>(loading...)</option>
        </select>
      </div>
      <hr/>
      <input id='pname' placeholder='profile filename' />
      <textarea id='pcontent' rows='6' placeholder='profile content (key=value lines)'></textarea>
      <div class='profiles-actions'>
        <button id='createBtn'>Create</button>
        <button id='saveBtn'>Save</button>
        <button id='deleteBtn'>Delete</button>
        <button id='loadBtn'>Load to daemon</button>
      </div>
      </div>
      </div>
    <div class='card'>
      <h2>Settings</h2>
      <div class='card-body'>
      <div class='settings-grid'>
        <div class='setting-row'><input id='safe_max' type='number' placeholder='Safe Max (kHz)'>
        <button onclick='setSetting("safe-max",document.getElementById("safe_max").value)'>Set Max</button></div>
        <div class='setting-row'><input id='safe_min' type='number' placeholder='Safe Min (kHz)'>
        <button onclick='setSetting("safe-min",document.getElementById("safe_min").value)'>Set Min</button></div>
        <div class='setting-row'><input id='temp_max' type='number' placeholder='Temp Max (C)'>
        <button onclick='setSetting("temp-max",document.getElementById("temp_max").value)'>Set Temp</button></div>
      </div>
      <hr/>
      <div class='settings-grid'>
        <!-- Sensor Source / Device controls moved into Settings (replaces excluded types + thermal zone UI) -->
        <div class='setting-row sensor-controls'>
          <div class='field'><label for='sensorGroupSelectMain'>Sensor Source</label>
            <select id='sensorGroupSelectMain' class='profiles-select'></select></div>
          <div class='field'><label for='hwmonSensorSelectMain'>Device</label>
            <select id='hwmonSensorSelectMain' class='profiles-select'></select></div>
        </div>

        <div class='setting-row avg-row'>
          <div class='avg-controls'>
            <button id='avgBtn' onclick='toggleAvgTemp()'>Use Avg Temp</button>
            <button id='sensorBtn' title='Manage excludes' class='sensor-btn' onclick='openExcludeModal()' aria-label='Exclude settings'>⚙</button>
          </div>
        </div>
      </div>
      </div>
      <hr/>
      <div class='settings-grid restart-grid'>
        <div class='setting-row restart'><button id='restartBtn' class='btn-danger'>Restart daemon</button></div>
      </div>

      </div>
      </div>
      </div>
    <div id='toast'></div>

    <!-- Excludes modal: manage excluded sensors/devices (no source/device selection) -->
    <div id='excludeModal' class='modal hidden'>
      <div class='modal-overlay'></div>
      <div class='modal-content'>
        <div class='modal-header'>
          <h3>Excluded Sensors / Devices</h3>
          <button class='btn-close' onclick='closeExcludeModal()' aria-label='Close' title='Close'>×</button>
        </div>
        <div id='excludeModalContent'>Loading...</div>
        <div class='modal-actions modal-actions-header'>
          <div class='modal-actions-right'>
            <button onclick='closeExcludeModal()' class='btn-secondary'>Cancel</button>
            <button id='excludeModalSaveBtn' onclick='saveExcludeModal()' class='btn-enabled'>Save</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Floating button to open skins modal (non-intrusive floating action button) -->
    <div id='confirmModal' class='modal hidden'>
      <div class='modal-overlay'></div>
      <div class='modal-content'>
        <div class='modal-message' id='confirmMessage'>Confirm?</div>
        <div class='modal-actions'>
          <button id='confirmOk' class='btn-danger'>Confirm</button>
          <button id='confirmCancel'>Cancel</button>
        </div>
      </div>
    </div>
    <!-- Skins management modal: lists available skins, preview, and allows activation -->
    <div id='skinsModal' class='modal hidden'>
      <div class='modal-overlay' id='skinsOverlay'></div>
      <div class='modal-content'>
        <div class='modal-header'>
          <div class='modal-row-title'>
            <h3 class='modal-title'>Skins</h3>
          </div>
          <div class='modal-row-actions'>
            <div class='header-left'>
              <button id='skinsResetBtn' class='btn-secondary btn-icon' title='Revert to default' aria-label='Revert to default'>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" aria-hidden="true" focusable="false">
                  <path fill="currentColor" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
                </svg>
                <span>Default</span>
              </button>
              
              <input type='file' id='skinFileInput' accept='.zip,.tgz,.tar,.gz,.tar.gz,.zip' class='hidden-file-input' aria-label='Choose skin archive file' />
              <div class='install-group'>
                <button id='skinsInstallBtn' class='btn-secondary' title='Install skin'>Install</button>
                <progress id='skinUploadProgress' class='upload-progress' value='0' max='100'></progress>
                <label class='install-activate'>
                  <input type='checkbox' id='skinActivateAfterInstall' title='Activate after install' />
                  <span>Activate after install</span>
                </label>
              </div>
            </div>
            <div class='header-right'>
            </div>
            <button id='skinsClose' class='btn-close' aria-label='Close skins modal'>×</button>
          </div>
        </div>
        <div id='skinsContainer' class='skins-list'>
          <!-- Items populated dynamically: .skin-card -->
        </div>
      </div>
      </div>
      <!-- Floating button to open skins modal (moved to end-of-body so on mobile it's rendered below content) -->
      <button id="skinFab" class="fab" title="Manage skins">Skins</button>
      <script>
      // Provide a global window.showConfirm fallback so code can call it before DOMContentLoaded
      if (typeof window.showConfirm !== 'function') {
        window.showConfirm = function(msg){ return new Promise((resolve)=>{ resolve(window.confirm(msg)); }); };
      }
      // Global confirm modal helper (declarations only, returned as a Promise)
      function showConfirmModal(message){
        return new Promise((resolve)=>{
          const modal = document.getElementById('confirmModal');
          const messageEl = document.getElementById('confirmMessage');
          if(!modal || !messageEl){
            // fallback to native confirm if DOM not ready or modal missing
            resolve(window.confirm(message));
            return;
          }
          messageEl.textContent = message;
          modal.classList.remove('hidden');
          const ok = document.getElementById('confirmOk');
          const cancel = document.getElementById('confirmCancel');
          function cleanup(){ modal.classList.add('hidden'); ok.removeEventListener('click', onOk); cancel.removeEventListener('click', onCancel); }
          function onOk(){ cleanup(); resolve(true); }
          function onCancel(){ cleanup(); resolve(false); }
          ok.addEventListener('click', onOk);
          cancel.addEventListener('click', onCancel);
          const onKey = (e)=>{ if(e.key === 'Escape'){ cleanup(); resolve(false); } };
          document.addEventListener('keydown', onKey, {once:true});
        });
      }
      var useAvgTemp = false;
      function showToast(message, type = 'success'){
        console.log('Showing toast:', message, type);
        const toast = document.getElementById('toast');
        console.log('Toast element:', toast);
        toast.innerText = message;
        if (type === 'success') {
          toast.style.background = 'green';
          toast.style.color = 'white';
        } else {
          toast.style.background = 'red';
          toast.style.color = 'white';
        }
        toast.style.display = 'block';
        setTimeout(() => { toast.style.display = 'none'; }, 3000);
      }
      function toggleAvgTemp() {
        console.log("toggleAvgTemp called");
        useAvgTemp = !useAvgTemp;
        const avgBtn = document.getElementById('avgBtn');
        avgBtn.textContent = useAvgTemp ? 'Disable Avg Temp' : 'Enable Avg Temp';
        if(useAvgTemp) avgBtn.classList.add('btn-enabled'); else avgBtn.classList.remove('btn-enabled');
        setSetting("use-avg-temp", useAvgTemp ? 1 : 0);
      }
      function update(){
        fetch('/api/status').then(r=>r.json()).then(d=>{
          document.getElementById('temp').textContent=d.temperature+'°C';
          document.getElementById('freq').textContent=(d.frequency/1000).toFixed(0)+' MHz';
          // Display sensor path (use effective_sensor when sensor is 'auto') and set tooltip to the full effective path.
          const sensorEl = document.getElementById('sensor');
          if (!d.sensor) {
            sensorEl.innerHTML = '<span>--</span>'; sensorEl.removeAttribute('title'); sensorEl.classList.remove('truncated');
          } else {
            // Prefer to show effective sensor when available (helps 'auto' mode reveal the chosen sensor)
            const showPath = (d.sensor === 'auto' && d.effective_sensor) ? d.effective_sensor : d.sensor;
            // Display shorter form by hiding common sysfs prefixes and replacing with leading dots for clarity
            let displayPath = String(showPath || '');
            if (displayPath.indexOf('/sys/class/hwmon') === 0) displayPath = '...' + displayPath.slice('/sys/class/hwmon'.length);
            else if (displayPath.indexOf('/sys/class/thermal') === 0) displayPath = '...' + displayPath.slice('/sys/class/thermal'.length);
            const safe = String(displayPath).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            sensorEl.innerHTML = '<span>' + safe + '</span>';
            // Keep full path in tooltip for copy/inspection
            sensorEl.setAttribute('title', showPath);
            // On narrow screens allow wrapping and do not use the RTL truncation (match breakpoint at 560px)
            if (window.matchMedia && window.matchMedia('(max-width:560px)').matches) {
              sensorEl.classList.remove('truncated');
              // ensure the inner span allows wrapping
              const span = sensorEl.querySelector('span'); if (span) { span.style.whiteSpace = 'normal'; span.style.wordBreak = 'break-word'; }
            } else {
              // Compact behavior: show tail and add leading ellipsis when truncated
              requestAnimationFrame(()=>{
                const span = sensorEl.querySelector('span');
                if (span && span.scrollWidth > sensorEl.clientWidth) sensorEl.classList.add('truncated'); else sensorEl.classList.remove('truncated');
              });
            }
          }
          // Show the user's preferred source if present, otherwise infer from current use_hwmon
          const srcEl = document.getElementById('sensor_source');
          if (d.sensor_source) {
            srcEl.textContent = (d.sensor_source === 'hwmon') ? 'HWMon' : (d.sensor_source === 'thermal') ? 'Thermal' : 'Auto';
          } else {
            srcEl.textContent = (d.use_hwmon ? 'HWMon' : 'Thermal');
          }
          // Populate sensor input if user isn't editing it
          // Populate sensor input if present (modal handles primary editing). Update hwmon/thermal UI
          const sp = document.getElementById('sensorPath'); if (sp && document.activeElement !== sp) sp.value = d.sensor || '';
          document.getElementById('avg').textContent=d.use_avg_temp;
          // Set form values - do not override a select the user is currently interacting with
          const tz = document.getElementById('thermalZoneSelect');
          const hw = document.getElementById('hwmonSummary');
          if (d.use_hwmon) {
            if (tz) tz.style.display = 'none';
            if (hw) { hw.classList.remove('hidden'); hw.classList.add('visible'); }
            loadHwmonsForSelect();
            const exclLabel = document.getElementById('excludedLabel'); if (exclLabel) exclLabel.textContent = 'Excluded devices';
          } else {
            if (tz) { tz.style.display = ''; if(document.activeElement !== tz) tz.value = d.thermal_zone; }
            if (hw) { hw.classList.remove('visible'); hw.classList.add('hidden'); }
            const exclLabel = document.getElementById('excludedLabel'); if (exclLabel) exclLabel.textContent = 'Excluded Types';
          }
          useAvgTemp = d.use_avg_temp;
          const du = document.getElementById('daemon_user'); if (du) du.textContent = d.running_user || '--';
          // Update avg button label to reflect current state
          const avgBtn = document.getElementById('avgBtn'); if(avgBtn) { avgBtn.textContent = useAvgTemp ? 'Disable Avg Temp' : 'Enable Avg Temp'; if(useAvgTemp) avgBtn.classList.add('btn-enabled'); else avgBtn.classList.remove('btn-enabled'); }
        }).catch(()=>{});
        refreshProfiles();
        loadSettings();
      }
      function loadSettings(){
        fetch('/api/settings/excluded-types').then(r=>r.json()).then(j=>{
          if (j && j.excluded_types !== undefined) {
            const el = document.getElementById('excludedTypes'); if(el && document.activeElement !== el) el.value = j.excluded_types;
          }
        }).catch(()=>{});
      }
            function setSetting(name,val){
              console.log("Setting " + name + " to " + val);
              fetch('/api/settings/'+name, {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({value: parseInt(val)})}).then(response => response.json()).then(j => {
                console.log("Response: ", j);
                if (j && j.saved) showToast('Saved to ' + j.saved_to, 'success');
                else if (j && j.status === 'ok') showToast('Updated', 'success');
                else showToast('Update not saved', 'error');
                // Special handling for thermal-zone to update the select immediately
                if (name === 'thermal-zone' && j && j.thermal_zone !== undefined) {
                  const tz = document.getElementById('thermalZoneSelect');
                  if (tz) tz.value = j.thermal_zone;
                }
                update();
              }).catch((e)=>{ console.log("Error: " + e); showToast("Error setting " + name, 'error'); });
            }
            function setSettingText(name,val){
              val = val ? val.trim() : val;
              console.log("Setting string " + name + " to " + val);
              // Return the fetch promise so callers can chain
              return fetch('/api/settings/'+name, {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({value: val})}).then(response => response.json()).then(j => {
                console.log("Response: ", j);
                if (j && j.saved) showToast('Saved to ' + j.saved_to, 'success');
                else if (j && j.status === 'ok') showToast('Updated', 'success');
                else showToast('Update not saved', 'error');
                update();
                return j;
              }).catch((e)=>{ console.log("Error: " + e); showToast("Error setting " + name, 'error'); throw e; });
            }
      function fetchDaemonVersion(){
        fetch('/api/daemon/version').then(r=>r.json()).then(j=>{ const v = j && j.version ? j.version : null; const el = document.querySelector('.topbar .version'); if(el && v) el.textContent = 'v'+v; }).catch(()=>{});
      }
      var _lastZoneRefresh = 0;
      function loadZonesForSelect(){
        // If daemon is using HWMon, don't load thermal zones; caller should use loadHwmonsForSelect instead
        fetch('/api/zones').then(r=>r.json()).then(data=>{
          const zones = (data.zones || []).slice();
          // Ensure numeric sort by zone number
          zones.sort((a,b)=> (parseInt(a.zone) || 0) - (parseInt(b.zone) || 0));
          const select = document.getElementById('thermalZoneSelect');
          select.innerHTML = '<option value="-1">Auto</option>';
          zones.forEach(z=>{
            const opt = document.createElement('option');
            opt.value = z.zone;
            const excluded = !!z.excluded;
            const temp_text = (z.temp === null || z.temp === undefined) ? '(no reading)' : `${z.temp}°C`;
            opt.textContent = `Zone ${z.zone}: ${z.type} - ${temp_text}` + (excluded ? ' (excluded)' : '');
            if (excluded) { opt.disabled = true; opt.style.color = '#999'; }
            select.appendChild(opt);
          });
          _lastZoneRefresh = Date.now();
        }).catch(()=>{});
      }

      // load list of hwmon devices (no textual summary in settings)
      function loadHwmonsForSelect() {
        fetch('/api/hwmons').then(r=>r.json()).then(data=>{
          // Intentionally no UI summary rendered here (removed as requested)
        }).catch(()=>{});
      }

      // Open the exclude-only modal
      function openExcludeModal(){ const modal = document.getElementById('excludeModal'); modal.classList.remove('hidden'); loadExcludesModal(); }
      function closeExcludeModal(){ document.getElementById('excludeModal').classList.add('hidden'); }

      // Populate main settings Source and Device selects
      function populateSensorControls(){
        Promise.all([fetch('/api/hwmons').then(r=>r.json()).catch(()=>({hwmons:[]})), fetch('/api/zones').then(r=>r.json()).catch(()=>({zones:[]})), fetch('/api/status').then(r=>r.json()).catch(()=>({}))])
        .then(([hwData, zData, status])=>{
          const hw = hwData.hwmons || [];
          const zones = zData.zones || [];
          const groupSel = document.getElementById('sensorGroupSelectMain');
          const deviceSel = document.getElementById('hwmonSensorSelectMain');
          if (!groupSel || !deviceSel) return;
          // Determine group selection
          let group = 'auto'; if (status && status.sensor_source) group = status.sensor_source;
          groupSel.innerHTML = '';
          groupSel.innerHTML += `<option value="auto"${group==='auto'?' selected':''}>Auto (HWMon-first)</option>`;
          groupSel.innerHTML += `<option value="hwmon"${group==='hwmon'?' selected':''}>HWMon</option>`;
          groupSel.innerHTML += `<option value="thermal"${group==='thermal'?' selected':''}>Thermal Zones</option>`;

          function populateDevices(g){
            deviceSel.innerHTML = '';
            if (g === 'hwmon'){
              deviceSel.innerHTML += `<option value="auto">(select a HWMon sensor)</option>`;
              hw.forEach(dev=>{
                dev.sensors.forEach(s=>{
                  const excluded = !!s.excluded;
                  const text = (dev.name||dev.id) + ' / ' + (s.label||s.id) + ' - ' + (s.temp===null? '(no reading)' : s.temp+'°C') + (excluded ? ' (excluded)' : '');
                  const opt = document.createElement('option');
                  opt.value = s.path;
                  opt.textContent = text;
                  if (excluded) { opt.disabled = true; opt.style.color = '#999'; }
                  deviceSel.appendChild(opt);
                });
              });
            } else if (g === 'thermal'){
              deviceSel.innerHTML += `<option value="-1">Auto</option>`;
              zones.forEach(z=>{
                const excluded = !!z.excluded;
                const temp_text = (z.temp===null||z.temp===undefined)? '(no reading)': z.temp+'°C';
                const opt = document.createElement('option');
                opt.value = z.zone;
                opt.textContent = `Zone ${z.zone}: ${z.type} - ${temp_text}` + (excluded ? ' (excluded)' : '');
                if (excluded) { opt.disabled = true; opt.style.color = '#999'; }
                deviceSel.appendChild(opt);
              });
            } else { const eff = (status && status.use_hwmon) ? 'hwmon' : 'thermal'; return populateDevices(eff); }
          }

          populateDevices(group);

          // change handlers
          groupSel.onchange = function(){ populateDevices(this.value); if (this.value === 'auto'){ setSettingText('sensor-source','auto'); } else { setSettingText('sensor-source', this.value); } };
          deviceSel.onchange = function(){ const g = groupSel.value || 'auto'; if (g === 'hwmon'){ const v = this.value || 'auto'; if (v === 'auto') setSettingText('sensor','auto'); else setSettingText('sensor', v); setSettingText('sensor-source','hwmon'); } else if (g === 'thermal'){ setSetting('thermal-zone', this.value); setSettingText('sensor','auto'); setSettingText('sensor-source','thermal'); } };

          // No textual summary is displayed in Settings anymore; nothing to render here
          // no-op
        }).catch(()=>{});
      }

      // Excludes modal: show checkboxes only for the active group
      function loadExcludesModal(){
        const el = document.getElementById('excludeModalContent'); el.innerHTML = 'Loading...';
        Promise.all([fetch('/api/hwmons').then(r=>r.json()).catch(()=>({hwmons:[]})), fetch('/api/zones').then(r=>r.json()).catch(()=>({zones:[]})), fetch('/api/status').then(r=>r.json()).catch(()=>({})), fetch('/api/settings/excluded-types').then(r=>r.json()).catch(()=>({}))]).then(([hwData, zData, status, exclJ])=>{
          const hw = hwData.hwmons || [];
          const zones = zData.zones || [];
          const curExcluded = (exclJ && exclJ.excluded_types) ? exclJ.excluded_types.split(',').map(s=>s.trim()).filter(Boolean) : [];
          const groupSelMain = document.getElementById('sensorGroupSelectMain');
          const deviceSelMain = document.getElementById('hwmonSensorSelectMain');
          const group = (groupSelMain && groupSelMain.value) ? groupSelMain.value : ((status && status.sensor_source) ? status.sensor_source : ((status && status.use_hwmon) ? 'hwmon' : 'thermal'));
          let out = '<div class="excludes-scroll">';
          if (group === 'hwmon'){
            hw.forEach(dev=>{
              out += `<div class='exclude-group'>`;
              out += `<div class='exclude-group-header'>${dev.name || dev.id} <small class='exclude-group-id'>${dev.id}</small></div>`;
              dev.sensors.forEach(s=>{
                const excl = curExcluded.includes((s.label||dev.name||s.id).toLowerCase()) ? 'checked' : '';
                out += `<div class='exclude-item'><label><input type="checkbox" class="hwmonExclude" data-name="${(s.label||dev.name||s.id).replace(/\"/g,'') }" ${excl}> <span class='exclude-item-label'>${s.label||s.id}</span> <span class='exclude-item-meta'>${s.temp===null? '(no reading)':s.temp+'°C'}</span></label></div>`;
              });
              out += '</div>';
            });
          } else if (group === 'thermal'){
            zones.forEach(z=>{
              const name = (z.type||('zone'+z.zone));
              const checked = curExcluded.includes(name.toLowerCase()) ? 'checked' : '';
              out += `<div class='exclude-group'>`;
              out += `<div class='exclude-group-header'>Zone ${z.zone} <small class='exclude-group-id'>${name}</small></div>`;
              out += `<div class='exclude-item'><label><input type="checkbox" class="hwmonExclude" data-name="${name.replace(/\"/g,'')}" ${checked}> <span class='exclude-item-label'>${name}</span> <span class='exclude-item-meta'>${z.temp===null? '(no reading)':z.temp+'°C'}</span></label></div>`;
              out += `</div>`;
            });
          }
          out += '</div>';
          el.innerHTML = out;
        }).catch(()=>{ el.innerHTML = 'Failed to load excludes'; });
      }

      function saveExcludeModal(){
        // collect excludes from checkboxes
        const exclBoxes = document.querySelectorAll('#excludeModal .hwmonExclude');
        let newExcl = [];
        exclBoxes.forEach(cb=>{ if (cb.checked) newExcl.push(cb.getAttribute('data-name').toLowerCase()); });
        // If user deselects all, send 'clear' so server clears the config
        const payload = (newExcl.length === 0) ? 'clear' : newExcl.join(',');
        setSettingText('excluded-types', payload).then(()=>{
          showToast('Excludes saved', 'success');
          closeExcludeModal();
          setTimeout(()=>{ populateSensorControls(); update(); }, 500);
        }).catch(()=>{
          showToast('Failed to save excludes', 'error');
        });
      }

      // Debounced refresh helper for select open events
      function refreshZonesDebounced(){
        const now = Date.now();
        if (now - _lastZoneRefresh > 2000) loadZonesForSelect();
      }
      function refreshProfiles(){
        fetch('/api/profiles').then(r=>r.json()).then(data=>{
          const list = data.profiles || [];
          const select = document.getElementById('profilesSelect');
          // If the user actively has the select focused, skip modifying it to avoid resetting while interacting
          if(document.activeElement === select) return;
          const prev = select.value; // remember user's current selection
          select.innerHTML = '';
          if(!list || !Array.isArray(list) || list.length===0){
            const opt = document.createElement('option'); opt.value=''; opt.textContent='(no profiles)'; select.appendChild(opt); return;
          }
          const placeholder = document.createElement('option'); placeholder.value=''; placeholder.textContent='(select a profile)'; select.appendChild(placeholder);
          list.forEach(p=>{
            const opt = document.createElement('option'); opt.value = p.name; opt.textContent = p.name; select.appendChild(opt);
          });
          // restore previous selection if still present (do not auto-load)
          if(prev){
            const found = Array.from(select.options).some(o=>o.value===prev);
            if(found) select.value = prev;
          }
          // only load into editor when user changes the selection
          select.onchange = function(){ if(this.value) loadProfileToEditor(this.value); };
        }).catch(()=>{
          const select = document.getElementById('profilesSelect'); select.innerHTML=''; const opt=document.createElement('option'); opt.value=''; opt.textContent='(failed)'; select.appendChild(opt);
        });
      }
      function loadProfileToEditor(name){
        fetch('/api/profiles/'+encodeURIComponent(name)).then(r=>{ if(!r.ok) throw 0; return r.text(); }).then(t=>{
          document.getElementById('pname').value = name;
          document.getElementById('pcontent').value = t;
          showToast('Profile loaded to editor', 'success');
        }).catch(()=>showToast('Failed to load profile', 'error'));
      }
      function createProfile(){
        const name = document.getElementById('pname').value.trim(); const content = document.getElementById('pcontent').value;
        if(!name){ alert('Enter filename'); return; }
        fetch('/api/profiles', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({name,content})}).then(r=>{ if(r.ok){ showToast('Profile created', 'success'); refreshProfiles(); } else showToast('Create failed', 'error'); });
      }
      function saveProfile(){
        const name = document.getElementById('pname').value.trim(); const content = document.getElementById('pcontent').value;
        if(!name){ alert('Enter filename'); return; }
        fetch('/api/profiles/'+encodeURIComponent(name), {method:'PUT', headers:{'Content-Type':'application/json'}, body:JSON.stringify({content})}).then(r=>{ if(r.ok){ showToast('Profile saved', 'success'); refreshProfiles(); } else showToast('Save failed', 'error'); });
      }
      async function deleteProfile(){
        const name = document.getElementById('pname').value.trim(); if(!name){ alert('Enter filename'); return; }
        const ok = await window.showConfirm('Delete ' + name + '?');
        if(!ok) return;
        fetch('/api/profiles/'+encodeURIComponent(name), {method:'DELETE'}).then(r=>{ if(r.ok){ showToast('Profile deleted', 'success'); document.getElementById('pname').value=''; document.getElementById('pcontent').value=''; refreshProfiles(); } else showToast('Delete failed', 'error'); });
      }
      function loadProfile(){
        const name = document.getElementById('pname').value.trim(); if(!name){ alert('Enter filename'); return; }
        fetch('/api/command', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({cmd:'load-profile '+name})}).then(r=>r.json()).then(j=>{ if(j && j.ok){ showToast('Profile loaded to daemon', 'success'); } else showToast('Load failed', 'error'); }).catch(()=>showToast('Load failed', 'error'));
      }
      document.addEventListener('DOMContentLoaded', ()=>{
        document.getElementById('createBtn').addEventListener('click', createProfile);
        document.getElementById('saveBtn').addEventListener('click', saveProfile);
        document.getElementById('deleteBtn').addEventListener('click', deleteProfile);
        document.getElementById('loadBtn').addEventListener('click', loadProfile);
        loadZonesForSelect();
        // Populate sensor controls (source/device) moved into Settings
        populateSensorControls();
        // Refresh zones when the user opens the select (keyboard/mouse/touch) with a small debounce
        const tzSelect = document.getElementById('thermalZoneSelect');
        if (tzSelect) {
          tzSelect.addEventListener('focus', refreshZonesDebounced);
          tzSelect.addEventListener('mousedown', refreshZonesDebounced);
          tzSelect.addEventListener('touchstart', refreshZonesDebounced, {passive:true});
        }
        // set CSS viewport variable for mobile dynamic viewport height (dvh) support
        (function setDvh(){
          const update = ()=>{
            const h = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;
            document.documentElement.style.setProperty('--dvh', (h * 0.01) + 'px');
          };
          // Throttle updates to avoid layout thrashing
          let t = 0;
          const throttled = ()=>{ if(t) return; t = requestAnimationFrame(()=>{ update(); t = 0; }); };
          update();
          window.addEventListener('resize', throttled, {passive:true});
          window.addEventListener('orientationchange', throttled, {passive:true});
          window.addEventListener('touchstart', throttled, {passive:true});
          window.addEventListener('touchmove', throttled, {passive:true});
          window.addEventListener('touchend', throttled, {passive:true});
          window.addEventListener('focus', throttled, {passive:true});
          window.addEventListener('blur', throttled, {passive:true});
          window.addEventListener('pageshow', throttled, {passive:true});
          document.addEventListener('visibilitychange', throttled, {passive:true});
          if(window.visualViewport){
            try{ window.visualViewport.addEventListener('resize', throttled); window.visualViewport.addEventListener('scroll', throttled); }catch(e){}
          }
        })();
        fetchDaemonVersion();
        // Modal confirm helper (use a Promise so code can await it) — global definition already exists
        // Ensure global showConfirm uses the modal (override fallback)
        window.showConfirm = showConfirmModal;
        // Buttons for daemon control
        const restartBtn = document.getElementById('restartBtn');
        if (restartBtn) restartBtn.addEventListener('click', async ()=>{
          const ok = await window.showConfirm('Restart daemon?');
          if(!ok) return;
          fetch('/api/daemon/restart',{method:'POST'}).then(r=>{ if(r.ok) showToast('Daemon restarting', 'success'); else showToast('Failed to restart', 'error'); }).catch(()=>showToast('Failed to restart', 'error'));
        });
        // No shutdown button in web UI — leaving shutdown operations out for safety
        setInterval(update,1000); update();
        // Skins UI: open/close, fetch list and handle activate/preview
        const skinFab = document.getElementById('skinFab');
        const skinsModal = document.getElementById('skinsModal');
        const skinsOverlay = document.getElementById('skinsOverlay');
        const skinsClose = document.getElementById('skinsClose');
        if (skinFab) skinFab.addEventListener('click', () => openSkinsModal());
        if (skinsClose) skinsClose.addEventListener('click', () => closeSkinsModal());
        if (skinsOverlay) skinsOverlay.addEventListener('click', () => closeSkinsModal());
        const skinsResetBtn = document.getElementById('skinsResetBtn');
        if (skinsResetBtn) skinsResetBtn.addEventListener('click', async ()=>{ if (await window.showConfirm('Revert to default assets?')) resetToDefault(); });
        const skinsInstallBtn = document.getElementById('skinsInstallBtn');
        const skinFileInput = document.getElementById('skinFileInput');
        const skinActivateAfterInstall = document.getElementById('skinActivateAfterInstall');
        if (skinsInstallBtn && skinFileInput) {
          skinsInstallBtn.addEventListener('click', ()=>{ skinFileInput.click(); });
          skinFileInput.addEventListener('change', async (e)=>{
            const f = e.target.files && e.target.files[0]; if(!f) return; const activate = skinActivateAfterInstall && skinActivateAfterInstall.checked;
            await installSkin(f, activate);
            // clear the input value so change events fire again for same file
            skinFileInput.value = '';
          });
        }

        function openSkinsModal(){
          refreshSkinsList();
          skinsModal.classList.remove('hidden');
        }
        function closeSkinsModal(){
          skinsModal.classList.add('hidden');
        }
        function refreshSkinsList(){
          fetch('/api/skins').then(r=>r.json()).then(data=>{
            const container = document.getElementById('skinsContainer');
            container.innerHTML = '';
            const list = (data && data.skins) ? data.skins : [];
            if(list.length === 0){ container.innerHTML = '<div style="padding:12px;color:#bbb">No skins installed</div>'; return; }
            list.forEach(s => {
              const card = document.createElement('div'); card.className = 'skin-card';
              card.style.width = '220px'; card.style.background='#111'; card.style.border='1px solid #333'; card.style.borderRadius='8px'; card.style.padding='8px'; card.style.boxSizing='border-box';
              const title = document.createElement('div'); title.textContent = s.name || s.id; title.style.fontWeight='600'; title.style.marginBottom='6px'; title.style.color='#fff';
              const preview = document.createElement('img'); preview.src = '/skins/'+encodeURIComponent(s.id)+'/preview.png'; preview.alt = s.name || s.id; preview.style.width='100%'; preview.style.maxHeight='120px'; preview.style.objectFit='cover'; preview.style.borderRadius='4px'; preview.style.background='#222';
              const meta = document.createElement('div'); meta.style.marginTop='8px'; meta.style.display='flex'; meta.style.gap='6px'; meta.style.justifyContent='space-between';
              const allowJS = document.createElement('span'); allowJS.textContent = s.allow_extra_js ? 'Extra JS allowed' : ''; allowJS.style.color = s.allow_extra_js ? '#28a745' : '#999'; allowJS.style.fontSize='0.85em';
              const actions = document.createElement('div'); actions.className = 'skin-actions';
              const toggleBtn = document.createElement('button');
              toggleBtn.textContent = s.active ? 'Deactivate' : 'Activate';
              toggleBtn.className = 'skin-action-btn';
              if (s.active) toggleBtn.classList.add('active');
              if (s.active) { toggleBtn.addEventListener('click', ()=>{ deactivateSkin(s.id); }); card.style.borderColor = '#28a745'; }
              else { toggleBtn.addEventListener('click', ()=>{ activateSkin(s.id); }); }
              actions.appendChild(toggleBtn);
              // Add remove button
              const removeBtn = document.createElement('button');
              removeBtn.textContent = 'Remove';
              removeBtn.className = 'btn-danger skin-action-btn';
              removeBtn.addEventListener('click', async ()=>{ if(await window.showConfirm('Remove skin '+s.id+'?')) removeSkin(s.id); });
              actions.appendChild(removeBtn);
              card.appendChild(title); card.appendChild(preview); meta.appendChild(allowJS); meta.appendChild(actions); card.appendChild(meta);
              container.appendChild(card);
            });
          }).catch(e=>{ console.log('Failed to fetch skins', e); const container = document.getElementById('skinsContainer'); container.innerHTML = '<div style="padding:12px;color:#ddd">Failed to query skins</div>'; });
        }
        function deactivateSkin(id){
          fetch('/api/skins/'+encodeURIComponent(id)+'/deactivate', {method:'POST'}).then(r=>{
            if(r.ok) { showToast('Deactivated '+id+'', 'success'); setTimeout(()=>{ closeSkinsModal(); window.location.reload(); }, 350); } else { showToast('Deactivation failed', 'error'); }
          }).catch(e=>{ showToast('Deactivation error', 'error'); console.log(e); });
        }
        function resetToDefault(){
          fetch('/api/skins/default', {method:'POST'}).then(r=>{
            if(r.ok){ showToast('Reverted to default', 'success'); setTimeout(()=>{ closeSkinsModal(); window.location.reload(); }, 350); } else { showToast('Failed to revert', 'error'); }
          }).catch(e=>{ showToast('Failed to revert', 'error'); console.log(e); });
        }
        function activateSkin(id){
          fetch('/api/skins/'+encodeURIComponent(id)+'/activate', {method:'POST'}).then(r=>{
            if(r.ok) { showToast('Activated '+id+'', 'success'); setTimeout(()=>{ closeSkinsModal(); window.location.reload(); }, 350); } else { showToast('Activation failed', 'error'); }
          }).catch(e=>{ showToast('Activation error', 'error'); console.log(e); });
        }
        // Install a skin file (tar/gzip/zip) - encode to base64 and send to server
        async function installSkin(file, activate=false){
          try{
            // server enforces max decoded size about 10MB; let's block larger files early
            if (file.size > 15 * 1024 * 1024) { showToast('File too large (>15MB)', 'error'); return; }
            const arr = await new Promise((resolve,reject)=>{ const fr = new FileReader(); fr.onerror = ()=>reject(fr.error); fr.onload = ()=>resolve(fr.result); fr.readAsArrayBuffer(file); });
            // convert arraybuffer to base64
            const bytes = new Uint8Array(arr);
            let binary = '';
            const chunk = 0x8000;
            for (let i = 0; i < bytes.length; i += chunk) {
              binary += String.fromCharCode.apply(null, Array.prototype.slice.call(bytes.subarray(i, Math.min(i + chunk, bytes.length))));
            }
            const b64 = btoa(binary);
            const bodyObj = { archive: b64 };
            if (activate) bodyObj.activate = "true";
            // Use XHR so we can track upload progress reliably
            const progressEl = document.getElementById('skinUploadProgress');
            progressEl.value = 0; progressEl.style.display = 'inline-block';
            showToast('Uploading skin...','success');
            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/api/skins/upload');
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.upload.onprogress = function(e){
              if (e.lengthComputable) {
                const pct = Math.round((e.loaded / e.total) * 100);
                progressEl.value = pct;
              }
            };
            const payload = JSON.stringify(bodyObj);
            const prom = new Promise((resolve, reject) => {
              xhr.onload = function(){
                progressEl.style.display = 'none';
                if (xhr.status >= 200 && xhr.status < 300) {
                  try{ const res = JSON.parse(xhr.responseText); resolve({ok:true, body: res}); } catch(e){ resolve({ok:true, body: null}); }
                } else { resolve({ok:false, status: xhr.status, body: xhr.responseText}); }
              };
              xhr.onerror = function(){ progressEl.style.display = 'none'; reject(new Error('Upload failed')); };
            });
            xhr.send(payload);
            const resp = await prom;
            if (!resp.ok) { showToast('Upload failed', 'error'); return; }
            const j = resp.body; if (j && j.installed) { showToast('Installed '+j.installed, 'success'); setTimeout(()=>{ refreshSkinsList(); closeSkinsModal(); window.location.reload(); }, 350); } else { showToast('Install failed', 'error'); }
          } catch (e){ console.log('installSkin error', e); showToast('Install error', 'error'); }
        }
        async function removeSkin(id){
          try{
            const resp = await fetch('/api/skins/'+encodeURIComponent(id)+'/remove', {method:'POST'});
            if (resp.ok) { showToast('Removed '+id, 'success'); setTimeout(()=>{ refreshSkinsList(); closeSkinsModal(); window.location.reload(); }, 350); }
            else { showToast('Failed to remove skin', 'error'); }
          } catch(e){ console.log('removeSkin error', e); showToast('Failed to remove skin', 'error'); }
        }
      });
    </script>
  </body>
</html>
